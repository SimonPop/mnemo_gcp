from pathlib import Path
import numpy as np
import json
import panphon
import json
from sklearn.cluster import KMeans

IPA_CHARS = [
    "s",
    "l",
    "ɤ",
    "d",
    "t",
    "ʃ",
    "ŋ",
    "z",
    "ʐ",
    "i",
    "n",
    "ɛ",
    "m",
    "r",
    "k",
    "ɻ",
    "θ",
    "ʈ",
    "ɨ",
    "ʊ",
    "e",
    "ɑ",
    "v",
    "a",
    "ɡ",
    "h",
    "ɥ",
    "p",
    "œ",
    "ɔ",
    "ʃ",
    "t",
    "æ",
    "d",
    "ʒ",
    "ɯ",
    "ɪ",
    "w",
    "o",
    "u",
    "ə",
    "j",
    "y",
    "b",
    "ɕ",
    "ɹ",
    "x",
    "ʒ",
    "ð",
    "ʂ",
    "f",
]

NON_IPA_CHARS = ["ʰ",
    "P",
    "I",
    "ʧ",
    "A"]

class CustomPhonemes():
    """
    CustomPhonemes class is used to convert a sequence written in IPA to a custom alphabet containing less letters.
    This is made so that the distance between words using levenstein based approaches is reduced.
    
    Inspired by the 15 most stable lexemes (Dolgopolsky, 1986), we intend to generalize this approach by clustering IPA 
    characters based on their phonetic features as generated by the PanPhon library.
    """
    def __init__(self):
        self.level_dict = {}
        for level in [5, 10, 15, 20]:
            f = open(Path(__file__).parent / 'phonemes_{}.json'.format(level), encoding='utf-8')
            data = json.load(f)
            f.close()
            self.level_dict[level] = data

    def _create_cluster(self, level: int) -> None:
        """Creates and dumps custom alphabet dictionary.

        Args:
            level (int): Number of letters to include in the alphabet.
        """
        X = self._get_ipa_features()
        y_dict = self._cluster_features(X, level)
        self._dump_cluster(y_dict, level)

    def _get_ipa_features(self) -> np.array:
        """Collects features for each of the IPA characters in the list.

        Returns:
            np.array: Phonetic feature matrix of IPA characters.
        """
        ft = panphon.FeatureTable()
        X = np.array([ft.word_to_vector_list(ipa_char, numeric=True)[0] for ipa_char in IPA_CHARS])
        return X

    def _cluster_features(self, X, n_clusters: int) -> dict:
        """Clusters features into groups and adds an individual group for each non seleted IPA characters.

        Args:
            X (_type_): Feature matrix
            n_clusters (int): Number of clusters to group IPA characters in (excluding non IPA ones).

        Returns:
            dict: Dictionnary {character -> cluster n°} 
        """
        model = KMeans(n_clusters=n_clusters)
        classes = model.fit_predict(X).astype(int)
        y_dict = dict(sorted(list(zip(IPA_CHARS, classes)), key=lambda tup: tup[1]))
        for i, non_ipa in enumerate(NON_IPA_CHARS):
            y_dict[non_ipa] = i + n_clusters
        # for k, v in y.items():
        #     y[k] = int(v)
        return y_dict

    def _dump_cluster(self, y_dict: dict, level: int) -> None:
        """Dumps the group dictionnary to a json file.

        Args:
            y_dict (dict): Dictionnary {character -> cluster n°} 
            level (int): Number of letters to include in the alphabet.
        """
        json_output = json.dumps(y_dict, indent=4)
        with open("phonemes_{}.json".format(level), "w", encoding='utf-8') as outfile:
            outfile.write(json_output)

    def convert(self, ipa: str, level: int = 10) -> str:
        """Converts an IPA sequence to a custom alphabet of given level (number of letters). 

        Args:
            ipa (str): Sequence of IPA letters to be converted.
            level (int, optional): Level of precision of the alphabet (number of letters included). Defaults to 10.

        Returns:
            _type_: Same sequence written in custom alphabet instead.
        """
        custom_dict = self.level_dict[level]
        return ''.join([chr(65 + custom_dict[x]) if x in custom_dict else x for x in ipa])